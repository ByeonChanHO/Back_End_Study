# Event Driven Architecture
> ## [ 정의 ]
>>
>> <p align="center">
>>          <img src = "https://user-images.githubusercontent.com/38696775/205497363-e33c5a90-fd78-4b19-90fd-a743ad6454b1.png"/>
>> </p>
>>                                                                                                                                           
>> Event Driven Architecture 이란 이벤트를 중심으로 생산, 소비을 돌아가는 아키텍쳐이다
>>
> ## [이벤트란?]
>>  시스템 하드웨어 또는 소프트웨어 상태의 변화 또는 중대 사건의 발생을 의미합니다
>>  
>>  즉, 마우스 클릭, 키보드 입력, 데이터 변화 등이 될 수 있습니다.
>>  
> ## [구성요소]
>> 
>> Event Driven Architecture 는 Event producer와 Event consumer, Event Channels 로 구성
>> 
>> ![image](https://user-images.githubusercontent.com/38696775/212904950-b32aa6e6-df5b-4eee-bf79-d09cc6f77ddd.png)
>> 
>> Event Producer : 이벤트를 감지하며 해당 이벤트를 메시지로 재구성하여 보내는 역할
>> 
>> Evnet Consumer : 해당 이벤트의 알림을 받아, 해당 이벤트를 가져와 처리하는 역할
>> 
>> Event Channels : 이벤트를 생성자에서 소비자로 옮기는 역할을 하며 해당 이벤트 처리를 비동기적으로 수행한다.
>> 
>> 
>> <strong> [주의 특성] </strong> 
>>> 
>>> Event Producer은 단지 이벤트를 재구성해서 Channel로 보낼 뿐, 어떤 소비자가 이 이벤트를 가져가는지 모르고, Event Consumer도 이벤트를 가져올뿐 누가 생산하는지는 서로 모르는 구조이다. 
> ## [이벤트 기반 아키텍처 모델]
>> pub/sub 모델과 Event streaming 모델 총 2가지의 이벤트 기반 아키텍처가 존재한다.
>> ### [Pub / Sub Model]
>>> 이벤트 스트림 구독 기반의 메시징 infrasture 로 이벤트 발생 후 또는 게시 후에 알림을 받아야하는 구독자한테 바로 이벤트가 전송됩니다.
>> ### [ Event Streaming Model ]
>> Event Streaming Model 을 사용하게 되면 이벤트가 로그에 기록이 됩니다.
>> 또한, 이벤트 소비자는 이벤트 스트림을 구독하지 않습니다
>> 스트림의 모든 부분에서 읽기가 가능하며 언제든지 스트림에 참여 가능
>>> [ Event Streaming 유형]
>>>> 1. Event stream processing
>>>>> Apache Kafka 와 같이 데이터 스트림 플랫폼을 사용하여 이벤트 스트림을 처리 또는 운송하는 걸 뜻한다.
>>>> 2. Simple event processing
>>>>> 이벤트가가 즉시 소비자 행동 트리거가 된다.
>>>> 3. Complex event processing
>>>>> 감지하기 위해 소비자는 이벤트를 처리해야한다?
> ## [이점]
>> 













> ## [ 배경 ]
>> Event Driven Architecture는 MSA의 문제점을 보완하고자 나온 구조입니다
>> 
>> 기존의 MSA는 단일 애플리케이션을 작은 서비스 모음으로 개발하는 방식인데, 각각 서비스를 자체 프로세스에서 실행되게 만들며 느슨한 연결(Loosely-coupled)구조로 HTTP 리소스인 REST와 같은 경량 메커니즘으로 각 서비스들끼리 통신합니다
>> 
>> 즉, 하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐입니다.
>> 
>> 하지만 MSA 방식에는 문제점이 존재했는데요
>> 
>> 바로 [Database Per Service](https://github.com/ByeonChanHO/Back_End_Study/blob/main/%EA%B3%B5%EB%B6%80%EB%B0%A9/Event%20Driven/Database%20Per%20Service%EB%A1%9C%20%EC%A0%84%ED%99%98.md) 를 적용하게 되면서 나타나는 문제점입니다
>> 
>> ### [ MSA Database Per Sevice로 인한 문제점 ]
>> 
>>> <strong>[ 비즈니스 흐름 수행 문제 ]</strong>
>>> 
>>> 하나의 공간에서 처리되던 로직이 여러 개의 공간으로 서비스가 분리되어 해당 기능을 수행하기 위해서 여러 서비스를 통신을 거쳐야한다.
>>> 
>>>> [ 닥터유 에너지바를 산다고 가정을 하자! ]
>>>> 
>>>> MSA 로 바뀌기 이전에는 하나의 기능이 여러 단계를 걸쳐서 닥터유 에너지바를 고객에게 전달을 한다.
>>>> 
>>>> 하지만 MSA 이후에는 각 단계별로 서비스가 구현 되었기에 menu -> order -> pay -> make -> delivery 서비스 순서대로 동작을 할 것이다.
>>>> 
>>>> 즉, 각 서비스 마다 통신을 하게 되고 이전 보다 시간이 걸리고 비즈니스 흐름이 복잡해진다.
>>> 
>>> <strong>[ 트랜잭션 관리 ]</strong>
>>> 
>>> 기존 Legacy 시스템에서는 문제 발생시 일괄적으로 commit 또는 rollback 처리나 이전에 발생한 상태 변경에 직접 접근하여 데이터 수정이 가능하였다.
>>> 
>>> 하지만 MSA 가 적용된 후, 각 서비스가 나눠져 일관적으로 commit 또는 rollback 하기가 어려워집니다.
>>> 
>>> <strong>[ 서비스 간 반정규화 데이터 동기 처리 문제 ]</strong>
>>> 
>>> 기존의 Legacy 시스템에서는 한곳에서 데이터를 관리하다 보니 반정규화가 생길 가능성이 적었습니다
>>> 
>>> 하지만 MSA가 적용된 후 각 서비스의 DB에 반정규화가 생길 가능성이 이전보다 높아지고, 해당 반정규화를 해소시키기위해 REST 통신을 하게 되면서 복잡성 및 성능이 안 좋아지게 된다.
>>> 
>>>> [ 각 서비스 DB에 쓰이는 테이블 컬럼이 있다고 가정하자! ]
>>>> 
>>>> 두개의 서비스가 있습니다 
>>>> 
>>>> 서비스1 DB 테이블은 닥터유 제품관련 데이터가 있다
>>>> 
>>>> 서비스2는 닥터유 에너지바관련 데이터가 있다.
>>>> 
>>>> 닥터유 제품에는 당연히 닥터유 에너지바를 제품으로 등록해 있다.
>>>> 
>>>> 근데 서비스2가 닥터유 에너지바의 이름을 닥터유+ 에너지바로 바꾸게 된다.
>>>> 
>>>> 이때 서비스1에서 에너지바 관련된 일로 서비스2를 호출 할 경우 반정규화가 생긴다.
>>>> 
>>>> 이를 해결하기 위해 서비스들끼리 계속 REST 통신하게 되면 복잡성이 커지고 성능을 떨어지게 된다.
>>>> 
>>> <strong>[ 시스템내 통합 문제 ]</strong>
>>> 
>>> 
>>>   
>>> 

>>
> ## [ 구성 요소 ]
>> 1. Event Producer(Generater, Publisher, Creater)
>>  생성된 이벤트 데이터를 Event bus에게 전달
>> 2. Event Bus(Router, Channel)
>>  이벤트 데이터를 저장하고 해당 데이터를 Event Consumer에게 전파하는 역할
>> 3. Event Consumer(Processor)
>>  수신된 이벤트 데이터를 식별하고 처리하는 역
>> ![image](https://user-images.githubusercontent.com/38696775/209245970-bbabe746-0c90-421d-b2bd-b1610a7a83ac.png)


> ## [ 이벤트 기반 아키텍처의 이점 ]
>>
>>1. 느슨한 결합 및 개발자 민첩성 향상
>>
>>이벤트 제작자는 이벤트 소비자와 논리적으로 구분됩니다. 이벤트의 프로덕션과 소비가 분리됨에 따라 서비스는 상호 운용이 가능하지만 서로 독립적으로 확장, 업데이트, 배포될 수 있습니다.
>>
>>느슨한 결합을 사용하면 종속 항목을 줄이고 다양한 언어와 프레임워크에서 서비스를 구현할 수 있습니다. 한 서비스의 로직을 변경할 필요 없이 이벤트 제작자와 수신자를 추가하거나 삭제할 수 있습니다. 이벤트를 폴링, 필터링, 라우팅하기 위해 커스텀 코드를 작성할 필요가 없습니다.
>>
>>2. 비동기 이벤트 및 복원력
>>
>>이벤트 기반 시스템에서는 이벤트가 비동기식으로 생성되며 응답을 기다리지 않고 이벤트가 발생할 때 실행할 수 있습니다. 구성요소가 느슨하게 결합된 경우 하나의 서비스가 실패해도 다른 서비스는 영향을 받지 않습니다. 필요한 경우 수신 서비스가 실패 지점부터 다시 시작하거나 이전 이벤트를 재생할 수 있도록 이벤트를 로깅할 수 있습니다.
>>
>>3. 내보내기 기반 메시징, 실시간 이벤트 스트림, 비용 절감
>>
>>이벤트 기반 시스템을 사용하면 내보내기 기반 메시징을 쉽게 수행할 수 있으며, 클라이언트가 원격 서비스에 상태 변경을 지속적으로 폴링하지 않고도 업데이트를 수신할 수 있습니다. 이렇게 푸시된 메시지는 즉석 데이터 처리, 변환, 실시간 분석에 사용할 수 있습니다. 또한 폴링이 적으면 네트워크 I/O가 줄어들고 비용이 절감됩니다.
>>
>>4. 간소화된 감사 및 이벤트 소싱
>>
>>이벤트 라우터의 중앙 집중식 위치는 감사를 단순화하고 라우터와 상호작용할 수 있는 사용자와 데이터에 액세스할 수 있는 사용자 및 리소스를 제어할 수 있게 해줍니다. 전송 중인 데이터와 저장 데이터를 모두 암호화할 수도 있습니다.
>>
>>또한 애플리케이션 상태의 모든 변경사항을 기록하는 아키텍처 패턴인 이벤트 소싱을 원래 적용된 순서와 동일하게 활용할 수 있습니다. 이벤트 소싱은 이전 상태를 재현하기 위해서나 비즈니스 기반 결정을 설명하는 표준 설명의 감사 목적으로 보관 가능한 변경할 수 없는 이벤트의 로그를 제공합니다.


## 참고
https://www.samsungsds.com/kr/insights/msa_architecture_edm.html#:~:text=Event%20Driven%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%8A%94%20%ED%8A%B9%EC%A0%95,%EC%9D%84%20%EC%88%98%ED%96%89%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.

https://cloud.google.com/eventarc/docs/event-driven-architectures?hl=ko.
